{"ast":null,"code":"import axios from 'axios';\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000';\nconst api = axios.create({\n  baseURL: API_BASE_URL,\n  withCredentials: true,\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\nlet isRefreshing = false;\nlet failedQueue = [];\nconst processQueue = (error = null, token = null) => {\n  failedQueue.forEach(prom => {\n    if (error) {\n      prom.reject(error);\n    } else {\n      prom.resolve(token);\n    }\n  });\n  failedQueue = [];\n};\napi.interceptors.request.use(config => {\n  var _document$querySelect;\n  const token = localStorage.getItem('accessToken');\n  const csrfToken = (_document$querySelect = document.querySelector('meta[name=\"csrf-token\"]')) === null || _document$querySelect === void 0 ? void 0 : _document$querySelect.getAttribute('content');\n  if (token) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  if (csrfToken) {\n    config.headers['X-CSRF-Token'] = csrfToken;\n  }\n  return config;\n});\n\n// Move authService definition before interceptors that use it\nconst authService = {\n  async login(credentials) {\n    try {\n      var _response$data$data;\n      console.log('🔑 Attempting login with credentials:', credentials);\n\n      // Log the full request details\n      console.log('📤 Request details:', {\n        url: `${api.defaults.baseURL}/auth/login`,\n        method: 'POST',\n        data: credentials,\n        headers: {\n          'Content-Type': 'application/json',\n          ...api.defaults.headers.common\n        }\n      });\n      const response = await api.post('/auth/login', credentials);\n      console.log('✅ Login response:', {\n        status: response.status,\n        statusText: response.statusText,\n        headers: response.headers,\n        data: response.data\n      });\n      if (response.data.success && (_response$data$data = response.data.data) !== null && _response$data$data !== void 0 && _response$data$data.accessToken) {\n        console.log('🔐 Login successful, storing access token');\n        localStorage.setItem('accessToken', response.data.data.accessToken);\n\n        // Make sure user data is properly set in the response\n        if (!response.data.data.user) {\n          console.warn('⚠️ Login successful but no user data in response');\n          response.data.data = {\n            ...response.data.data,\n            user: {\n              id: 0,\n              username: credentials.username,\n              email: `${credentials.username}@example.com`\n            }\n          };\n        }\n      } else {\n        console.warn('❌ Login response indicates failure:', response.data);\n      }\n      return response.data;\n    } catch (error) {\n      var _error$response, _error$response$data;\n      console.error('Login error:', error);\n      const errorMessage = ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || error.message || 'Login failed. Please check your network connection and try again.';\n      return {\n        success: false,\n        message: errorMessage\n      };\n    }\n  },\n  async logout() {\n    try {\n      const response = await api.post('/auth/logout');\n      localStorage.removeItem('accessToken');\n      return response.data;\n    } catch (error) {\n      var _error$response2, _error$response2$data;\n      return {\n        success: false,\n        message: ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || 'Logout failed'\n      };\n    }\n  },\n  async refreshToken() {\n    try {\n      var _response$data$data2;\n      const response = await api.post('/auth/refresh-token');\n      if (response.data.success && (_response$data$data2 = response.data.data) !== null && _response$data$data2 !== void 0 && _response$data$data2.accessToken) {\n        localStorage.setItem('accessToken', response.data.data.accessToken);\n      }\n      return response.data;\n    } catch (error) {\n      localStorage.removeItem('accessToken');\n      throw error;\n    }\n  }\n};\napi.interceptors.response.use(response => response, async error => {\n  var _originalRequest$url;\n  const originalRequest = error.config;\n\n  // If there's no response or the request config is missing, reject\n  if (!error.response || !originalRequest) {\n    return Promise.reject(error);\n  }\n  const isAuthRequest = (_originalRequest$url = originalRequest.url) === null || _originalRequest$url === void 0 ? void 0 : _originalRequest$url.includes('/auth/');\n  const isLoginPage = window.location.pathname === '/login';\n\n  // Handle 401 Unauthorized errors\n  if (error.response.status === 401) {\n    // If we're already on the login page or it's an auth request, reject\n    if (isLoginPage || isAuthRequest) {\n      return Promise.reject(error);\n    }\n\n    // If we're already refreshing the token, add the request to the queue\n    if (isRefreshing) {\n      return new Promise((resolve, reject) => {\n        failedQueue.push({\n          resolve: token => {\n            if (originalRequest.headers) {\n              originalRequest.headers.Authorization = `Bearer ${token}`;\n            }\n            resolve(api(originalRequest));\n          },\n          reject\n        });\n      });\n    }\n\n    // Mark that we're refreshing the token\n    isRefreshing = true;\n    try {\n      const response = await authService.refreshToken();\n      const {\n        accessToken\n      } = response.data || {};\n      if (accessToken) {\n        // Update the original request with the new token\n        if (originalRequest.headers) {\n          originalRequest.headers.Authorization = `Bearer ${accessToken}`;\n        }\n\n        // Process any queued requests with the new token\n        processQueue(null, accessToken);\n\n        // Retry the original request\n        return api(originalRequest);\n      } else {\n        // If no access token in response, redirect to login\n        if (!isLoginPage) {\n          window.location.href = '/login';\n        }\n        return Promise.reject(new Error('No access token in refresh response'));\n      }\n    } catch (refreshError) {\n      // Clear any stored tokens and redirect to login\n      localStorage.removeItem('accessToken');\n      if (!isLoginPage) {\n        window.location.href = '/login';\n      }\n      processQueue(refreshError, '');\n      return Promise.reject(refreshError);\n    } finally {\n      isRefreshing = false;\n    }\n  }\n\n  // For other errors, just reject\n  return Promise.reject(error);\n});\n\n// Export the authService that was defined earlier\nexport { authService };\nexport const weatherService = {\n  async getWeatherData(city = 'London') {\n    try {\n      const response = await api.get(`/weather?city=${encodeURIComponent(city)}`);\n      return response.data;\n    } catch (error) {\n      var _error$response3, _error$response3$data;\n      return {\n        success: false,\n        message: ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.message) || 'Failed to fetch weather data'\n      };\n    }\n  }\n};\nexport default api;","map":{"version":3,"names":["axios","API_BASE_URL","process","env","REACT_APP_API_URL","api","create","baseURL","withCredentials","headers","isRefreshing","failedQueue","processQueue","error","token","forEach","prom","reject","resolve","interceptors","request","use","config","_document$querySelect","localStorage","getItem","csrfToken","document","querySelector","getAttribute","Authorization","authService","login","credentials","_response$data$data","console","log","url","defaults","method","data","common","response","post","status","statusText","success","accessToken","setItem","user","warn","id","username","email","_error$response","_error$response$data","errorMessage","message","logout","removeItem","_error$response2","_error$response2$data","refreshToken","_response$data$data2","_originalRequest$url","originalRequest","Promise","isAuthRequest","includes","isLoginPage","window","location","pathname","push","href","Error","refreshError","weatherService","getWeatherData","city","get","encodeURIComponent","_error$response3","_error$response3$data"],"sources":["/Users/aparnar/CascadeProjects/streaming-platform/frontend/src/services/api.ts"],"sourcesContent":["import axios, { AxiosError, AxiosRequestConfig } from 'axios';\nimport { User, LoginFormData, WeatherData, ApiResponse } from '../types';\n\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000';\n\nconst api = axios.create({\n  baseURL: API_BASE_URL,\n  withCredentials: true,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\nlet isRefreshing = false;\nlet failedQueue: Array<{ resolve: (token: string) => void; reject: (error: any) => void }> = [];\n\nconst processQueue = (error: any = null, token: string | null = null) => {\n  failedQueue.forEach(prom => {\n    if (error) {\n      prom.reject(error);\n    } else {\n      prom.resolve(token!);\n    }\n  });\n  failedQueue = [];\n};\n\napi.interceptors.request.use((config) => {\n  const token = localStorage.getItem('accessToken');\n  const csrfToken = document.querySelector('meta[name=\"csrf-token\"]')?.getAttribute('content');\n  \n  if (token) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  \n  if (csrfToken) {\n    config.headers['X-CSRF-Token'] = csrfToken;\n  }\n  \n  return config;\n});\n\n// Move authService definition before interceptors that use it\nconst authService = {\n  async login(credentials: LoginFormData): Promise<ApiResponse<User>> {\n    try {\n      console.log('🔑 Attempting login with credentials:', credentials);\n      \n      // Log the full request details\n      console.log('📤 Request details:', {\n        url: `${api.defaults.baseURL}/auth/login`,\n        method: 'POST',\n        data: credentials,\n        headers: {\n          'Content-Type': 'application/json',\n          ...(api.defaults.headers.common as any)\n        }\n      });\n      \n      const response = await api.post('/auth/login', credentials);\n      \n      console.log('✅ Login response:', {\n        status: response.status,\n        statusText: response.statusText,\n        headers: response.headers,\n        data: response.data\n      });\n      \n      if (response.data.success && response.data.data?.accessToken) {\n        console.log('🔐 Login successful, storing access token');\n        localStorage.setItem('accessToken', response.data.data.accessToken);\n        \n        // Make sure user data is properly set in the response\n        if (!response.data.data.user) {\n          console.warn('⚠️ Login successful but no user data in response');\n          response.data.data = { \n            ...response.data.data, \n            user: { \n              id: 0, \n              username: credentials.username, \n              email: `${credentials.username}@example.com` \n            } \n          };\n        }\n      } else {\n        console.warn('❌ Login response indicates failure:', response.data);\n      }\n      \n      return response.data;\n    } catch (error: any) {\n      console.error('Login error:', error);\n      const errorMessage = error.response?.data?.message || \n                         error.message || \n                         'Login failed. Please check your network connection and try again.';\n      return {\n        success: false,\n        message: errorMessage,\n      };\n    }\n  },\n\n  async logout(): Promise<ApiResponse<null>> {\n    try {\n      const response = await api.post('/auth/logout');\n      localStorage.removeItem('accessToken');\n      return response.data;\n    } catch (error: any) {\n      return {\n        success: false,\n        message: error.response?.data?.message || 'Logout failed',\n      };\n    }\n  },\n\n  async refreshToken(): Promise<ApiResponse<{ accessToken: string }>> {\n    try {\n      const response = await api.post('/auth/refresh-token');\n      if (response.data.success && response.data.data?.accessToken) {\n        localStorage.setItem('accessToken', response.data.data.accessToken);\n      }\n      return response.data;\n    } catch (error: any) {\n      localStorage.removeItem('accessToken');\n      throw error;\n    }\n  },\n};\n\napi.interceptors.response.use(\n  (response) => response,\n  async (error: AxiosError) => {\n    const originalRequest = error.config as (AxiosRequestConfig & { _retry?: boolean }) | undefined;\n    \n    // If there's no response or the request config is missing, reject\n    if (!error.response || !originalRequest) {\n      return Promise.reject(error);\n    }\n\n    const isAuthRequest = originalRequest.url?.includes('/auth/');\n    const isLoginPage = window.location.pathname === '/login';\n\n    // Handle 401 Unauthorized errors\n    if (error.response.status === 401) {\n      // If we're already on the login page or it's an auth request, reject\n      if (isLoginPage || isAuthRequest) {\n        return Promise.reject(error);\n      }\n\n      // If we're already refreshing the token, add the request to the queue\n      if (isRefreshing) {\n        return new Promise((resolve, reject) => {\n          failedQueue.push({ \n            resolve: (token: string) => {\n              if (originalRequest.headers) {\n                originalRequest.headers.Authorization = `Bearer ${token}`;\n              }\n              resolve(api(originalRequest));\n            }, \n            reject \n          });\n        });\n      }\n\n      // Mark that we're refreshing the token\n      isRefreshing = true;\n\n      try {\n        const response = await authService.refreshToken();\n        const { accessToken } = response.data || {};\n\n        if (accessToken) {\n          // Update the original request with the new token\n          if (originalRequest.headers) {\n            originalRequest.headers.Authorization = `Bearer ${accessToken}`;\n          }\n          \n          // Process any queued requests with the new token\n          processQueue(null, accessToken);\n          \n          // Retry the original request\n          return api(originalRequest);\n        } else {\n          // If no access token in response, redirect to login\n          if (!isLoginPage) {\n            window.location.href = '/login';\n          }\n          return Promise.reject(new Error('No access token in refresh response'));\n        }\n      } catch (refreshError) {\n        // Clear any stored tokens and redirect to login\n        localStorage.removeItem('accessToken');\n        if (!isLoginPage) {\n          window.location.href = '/login';\n        }\n        processQueue(refreshError, '');\n        return Promise.reject(refreshError);\n      } finally {\n        isRefreshing = false;\n      }\n    }\n\n    // For other errors, just reject\n    return Promise.reject(error);\n  }\n);\n\n// Export the authService that was defined earlier\nexport { authService };\n\nexport const weatherService = {\n  async getWeatherData(city: string = 'London'): Promise<ApiResponse<WeatherData>> {\n    try {\n      const response = await api.get(`/weather?city=${encodeURIComponent(city)}`);\n      return response.data;\n    } catch (error: any) {\n      return {\n        success: false,\n        message: error.response?.data?.message || 'Failed to fetch weather data',\n      };\n    }\n  },\n};\n\nexport default api;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import axios from 'axios';\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000';\nconst api = axios.create({\n  baseURL: API_BASE_URL,\n  withCredentials: true,\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\nlet isRefreshing = false;\nlet failedQueue = [];\nconst processQueue = (error = null, token = null) => {\n  failedQueue.forEach(prom => {\n    if (error) {\n      prom.reject(error);\n    } else {\n      prom.resolve(token);\n    }\n  });\n  failedQueue = [];\n};\napi.interceptors.request.use(config => {\n  var _document$querySelect;\n  const token = localStorage.getItem('accessToken');\n  const csrfToken = (_document$querySelect = document.querySelector('meta[name=\"csrf-token\"]')) === null || _document$querySelect === void 0 ? void 0 : _document$querySelect.getAttribute('content');\n  if (token) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  if (csrfToken) {\n    config.headers['X-CSRF-Token'] = csrfToken;\n  }\n  return config;\n});\n\n// Move authService definition before interceptors that use it\nconst authService = {\n  async login(credentials) {\n    try {\n      var _response$data$data;\n      const response = await api.post('/auth/login', credentials);\n      if (response.data.success && (_response$data$data = response.data.data) !== null && _response$data$data !== void 0 && _response$data$data.accessToken) {\n        localStorage.setItem('accessToken', response.data.data.accessToken);\n      }\n      return response.data;\n    } catch (error) {\n      var _error$response, _error$response$data;\n      return {\n        success: false,\n        message: ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || 'Login failed'\n      };\n    }\n  },\n  async logout() {\n    try {\n      const response = await api.post('/auth/logout');\n      localStorage.removeItem('accessToken');\n      return response.data;\n    } catch (error) {\n      var _error$response2, _error$response2$data;\n      return {\n        success: false,\n        message: ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || 'Logout failed'\n      };\n    }\n  },\n  async refreshToken() {\n    try {\n      var _response$data$data2;\n      const response = await api.post('/auth/refresh-token');\n      if (response.data.success && (_response$data$data2 = response.data.data) !== null && _response$data$data2 !== void 0 && _response$data$data2.accessToken) {\n        localStorage.setItem('accessToken', response.data.data.accessToken);\n      }\n      return response.data;\n    } catch (error) {\n      localStorage.removeItem('accessToken');\n      throw error;\n    }\n  }\n};\napi.interceptors.response.use(response => response, async error => {\n  var _originalRequest$url;\n  const originalRequest = error.config;\n\n  // If there's no response or the request config is missing, reject\n  if (!error.response || !originalRequest) {\n    return Promise.reject(error);\n  }\n  const isAuthRequest = (_originalRequest$url = originalRequest.url) === null || _originalRequest$url === void 0 ? void 0 : _originalRequest$url.includes('/auth/');\n  const isLoginPage = window.location.pathname === '/login';\n\n  // Handle 401 Unauthorized errors\n  if (error.response.status === 401) {\n    // If we're already on the login page or it's an auth request, reject\n    if (isLoginPage || isAuthRequest) {\n      return Promise.reject(error);\n    }\n\n    // If we're already refreshing the token, add the request to the queue\n    if (isRefreshing) {\n      return new Promise((resolve, reject) => {\n        failedQueue.push({\n          resolve: token => {\n            if (originalRequest.headers) {\n              originalRequest.headers.Authorization = `Bearer ${token}`;\n            }\n            resolve(api(originalRequest));\n          },\n          reject\n        });\n      });\n    }\n\n    // Mark that we're refreshing the token\n    isRefreshing = true;\n    try {\n      const response = await authService.refreshToken();\n      const {\n        accessToken\n      } = response.data || {};\n      if (accessToken) {\n        // Update the original request with the new token\n        if (originalRequest.headers) {\n          originalRequest.headers.Authorization = `Bearer ${accessToken}`;\n        }\n\n        // Process any queued requests with the new token\n        processQueue(null, accessToken);\n\n        // Retry the original request\n        return api(originalRequest);\n      } else {\n        // If no access token in response, redirect to login\n        if (!isLoginPage) {\n          window.location.href = '/login';\n        }\n        return Promise.reject(new Error('No access token in refresh response'));\n      }\n    } catch (refreshError) {\n      // Clear any stored tokens and redirect to login\n      localStorage.removeItem('accessToken');\n      if (!isLoginPage) {\n        window.location.href = '/login';\n      }\n      processQueue(refreshError, '');\n      return Promise.reject(refreshError);\n    } finally {\n      isRefreshing = false;\n    }\n  }\n\n  // For other errors, just reject\n  return Promise.reject(error);\n});\n\n// Export the authService that was defined earlier\nexport { authService };\nexport const weatherService = {\n  async getWeatherData(city = 'London') {\n    try {\n      const response = await api.get(`/weather?city=${encodeURIComponent(city)}`);\n      return response.data;\n    } catch (error) {\n      var _error$response3, _error$response3$data;\n      return {\n        success: false,\n        message: ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.message) || 'Failed to fetch weather data'\n      };\n    }\n  }\n};\nexport default api;","map":{"version":3,"names":["axios","API_BASE_URL","process","env","REACT_APP_API_URL","api","create","baseURL","withCredentials","headers","isRefreshing","failedQueue","processQueue","error","token","forEach","prom","reject","resolve","interceptors","request","use","config","_document$querySelect","localStorage","getItem","csrfToken","document","querySelector","getAttribute","Authorization","authService","login","credentials","_response$data$data","response","post","data","success","accessToken","setItem","_error$response","_error$response$data","message","logout","removeItem","_error$response2","_error$response2$data","refreshToken","_response$data$data2","_originalRequest$url","originalRequest","Promise","isAuthRequest","url","includes","isLoginPage","window","location","pathname","status","push","href","Error","refreshError","weatherService","getWeatherData","city","get","encodeURIComponent","_error$response3","_error$response3$data"],"sources":["/Users/aparnar/CascadeProjects/streaming-platform/frontend/src/services/api.ts"],"sourcesContent":["import axios, { AxiosError, AxiosRequestConfig } from 'axios';\nimport { User, LoginFormData, WeatherData, ApiResponse } from '../types';\n\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000';\n\nconst api = axios.create({\n  baseURL: API_BASE_URL,\n  withCredentials: true,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\nlet isRefreshing = false;\nlet failedQueue: Array<{ resolve: (token: string) => void; reject: (error: any) => void }> = [];\n\nconst processQueue = (error: any = null, token: string | null = null) => {\n  failedQueue.forEach(prom => {\n    if (error) {\n      prom.reject(error);\n    } else {\n      prom.resolve(token!);\n    }\n  });\n  failedQueue = [];\n};\n\napi.interceptors.request.use((config) => {\n  const token = localStorage.getItem('accessToken');\n  const csrfToken = document.querySelector('meta[name=\"csrf-token\"]')?.getAttribute('content');\n  \n  if (token) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  \n  if (csrfToken) {\n    config.headers['X-CSRF-Token'] = csrfToken;\n  }\n  \n  return config;\n});\n\n// Move authService definition before interceptors that use it\nconst authService = {\n  async login(credentials: LoginFormData): Promise<ApiResponse<User>> {\n    try {\n      const response = await api.post('/auth/login', credentials);\n      if (response.data.success && response.data.data?.accessToken) {\n        localStorage.setItem('accessToken', response.data.data.accessToken);\n      }\n      return response.data;\n    } catch (error: any) {\n      return {\n        success: false,\n        message: error.response?.data?.message || 'Login failed',\n      };\n    }\n  },\n\n  async logout(): Promise<ApiResponse<null>> {\n    try {\n      const response = await api.post('/auth/logout');\n      localStorage.removeItem('accessToken');\n      return response.data;\n    } catch (error: any) {\n      return {\n        success: false,\n        message: error.response?.data?.message || 'Logout failed',\n      };\n    }\n  },\n\n  async refreshToken(): Promise<ApiResponse<{ accessToken: string }>> {\n    try {\n      const response = await api.post('/auth/refresh-token');\n      if (response.data.success && response.data.data?.accessToken) {\n        localStorage.setItem('accessToken', response.data.data.accessToken);\n      }\n      return response.data;\n    } catch (error: any) {\n      localStorage.removeItem('accessToken');\n      throw error;\n    }\n  },\n};\n\napi.interceptors.response.use(\n  (response) => response,\n  async (error: AxiosError) => {\n    const originalRequest = error.config as (AxiosRequestConfig & { _retry?: boolean }) | undefined;\n    \n    // If there's no response or the request config is missing, reject\n    if (!error.response || !originalRequest) {\n      return Promise.reject(error);\n    }\n\n    const isAuthRequest = originalRequest.url?.includes('/auth/');\n    const isLoginPage = window.location.pathname === '/login';\n\n    // Handle 401 Unauthorized errors\n    if (error.response.status === 401) {\n      // If we're already on the login page or it's an auth request, reject\n      if (isLoginPage || isAuthRequest) {\n        return Promise.reject(error);\n      }\n\n      // If we're already refreshing the token, add the request to the queue\n      if (isRefreshing) {\n        return new Promise((resolve, reject) => {\n          failedQueue.push({ \n            resolve: (token: string) => {\n              if (originalRequest.headers) {\n                originalRequest.headers.Authorization = `Bearer ${token}`;\n              }\n              resolve(api(originalRequest));\n            }, \n            reject \n          });\n        });\n      }\n\n      // Mark that we're refreshing the token\n      isRefreshing = true;\n\n      try {\n        const response = await authService.refreshToken();\n        const { accessToken } = response.data || {};\n\n        if (accessToken) {\n          // Update the original request with the new token\n          if (originalRequest.headers) {\n            originalRequest.headers.Authorization = `Bearer ${accessToken}`;\n          }\n          \n          // Process any queued requests with the new token\n          processQueue(null, accessToken);\n          \n          // Retry the original request\n          return api(originalRequest);\n        } else {\n          // If no access token in response, redirect to login\n          if (!isLoginPage) {\n            window.location.href = '/login';\n          }\n          return Promise.reject(new Error('No access token in refresh response'));\n        }\n      } catch (refreshError) {\n        // Clear any stored tokens and redirect to login\n        localStorage.removeItem('accessToken');\n        if (!isLoginPage) {\n          window.location.href = '/login';\n        }\n        processQueue(refreshError, '');\n        return Promise.reject(refreshError);\n      } finally {\n        isRefreshing = false;\n      }\n    }\n\n    // For other errors, just reject\n    return Promise.reject(error);\n  }\n);\n\n// Export the authService that was defined earlier\nexport { authService };\n\nexport const weatherService = {\n  async getWeatherData(city: string = 'London'): Promise<ApiResponse<WeatherData>> {\n    try {\n      const response = await api.get(`/weather?city=${encodeURIComponent(city)}`);\n      return response.data;\n    } catch (error: any) {\n      return {\n        success: false,\n        message: error.response?.data?.message || 'Failed to fetch weather data',\n      };\n    }\n  },\n};\n\nexport default api;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import axios from 'axios';\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000';\nconst api = axios.create({\n  baseURL: API_BASE_URL,\n  withCredentials: true,\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\nlet isRefreshing = false;\nlet failedQueue = [];\nconst processQueue = (error = null, token = null) => {\n  failedQueue.forEach(prom => {\n    if (error) {\n      prom.reject(error);\n    } else {\n      prom.resolve(token);\n    }\n  });\n  failedQueue = [];\n};\napi.interceptors.request.use(config => {\n  var _document$querySelect;\n  const token = localStorage.getItem('accessToken');\n  const csrfToken = (_document$querySelect = document.querySelector('meta[name=\"csrf-token\"]')) === null || _document$querySelect === void 0 ? void 0 : _document$querySelect.getAttribute('content');\n  if (token) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  if (csrfToken) {\n    config.headers['X-CSRF-Token'] = csrfToken;\n  }\n  return config;\n});\n\n// Move authService definition before interceptors that use it\nconst authService = {\n  async login(credentials) {\n    try {\n      var _response$data$data;\n      console.log('Attempting login with credentials:', credentials);\n      const response = await api.post('/auth/login', credentials);\n      console.log('Login response:', response.data);\n      if (response.data.success && (_response$data$data = response.data.data) !== null && _response$data$data !== void 0 && _response$data$data.accessToken) {\n        console.log('Login successful, storing access token');\n        localStorage.setItem('accessToken', response.data.data.accessToken);\n        // Make sure user data is properly set in the response\n        if (!response.data.data.user) {\n          console.warn('Login successful but no user data in response');\n          response.data.data = {\n            ...response.data.data,\n            user: {\n              username: credentials.username\n            }\n          };\n        }\n      } else {\n        console.warn('Login response indicates failure:', response.data);\n      }\n      return response.data;\n    } catch (error) {\n      var _error$response, _error$response$data;\n      console.error('Login error:', error);\n      const errorMessage = ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || error.message || 'Login failed. Please check your network connection and try again.';\n      return {\n        success: false,\n        message: errorMessage\n      };\n    }\n  },\n  async logout() {\n    try {\n      const response = await api.post('/auth/logout');\n      localStorage.removeItem('accessToken');\n      return response.data;\n    } catch (error) {\n      var _error$response2, _error$response2$data;\n      return {\n        success: false,\n        message: ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || 'Logout failed'\n      };\n    }\n  },\n  async refreshToken() {\n    try {\n      var _response$data$data2;\n      const response = await api.post('/auth/refresh-token');\n      if (response.data.success && (_response$data$data2 = response.data.data) !== null && _response$data$data2 !== void 0 && _response$data$data2.accessToken) {\n        localStorage.setItem('accessToken', response.data.data.accessToken);\n      }\n      return response.data;\n    } catch (error) {\n      localStorage.removeItem('accessToken');\n      throw error;\n    }\n  }\n};\napi.interceptors.response.use(response => response, async error => {\n  var _originalRequest$url;\n  const originalRequest = error.config;\n\n  // If there's no response or the request config is missing, reject\n  if (!error.response || !originalRequest) {\n    return Promise.reject(error);\n  }\n  const isAuthRequest = (_originalRequest$url = originalRequest.url) === null || _originalRequest$url === void 0 ? void 0 : _originalRequest$url.includes('/auth/');\n  const isLoginPage = window.location.pathname === '/login';\n\n  // Handle 401 Unauthorized errors\n  if (error.response.status === 401) {\n    // If we're already on the login page or it's an auth request, reject\n    if (isLoginPage || isAuthRequest) {\n      return Promise.reject(error);\n    }\n\n    // If we're already refreshing the token, add the request to the queue\n    if (isRefreshing) {\n      return new Promise((resolve, reject) => {\n        failedQueue.push({\n          resolve: token => {\n            if (originalRequest.headers) {\n              originalRequest.headers.Authorization = `Bearer ${token}`;\n            }\n            resolve(api(originalRequest));\n          },\n          reject\n        });\n      });\n    }\n\n    // Mark that we're refreshing the token\n    isRefreshing = true;\n    try {\n      const response = await authService.refreshToken();\n      const {\n        accessToken\n      } = response.data || {};\n      if (accessToken) {\n        // Update the original request with the new token\n        if (originalRequest.headers) {\n          originalRequest.headers.Authorization = `Bearer ${accessToken}`;\n        }\n\n        // Process any queued requests with the new token\n        processQueue(null, accessToken);\n\n        // Retry the original request\n        return api(originalRequest);\n      } else {\n        // If no access token in response, redirect to login\n        if (!isLoginPage) {\n          window.location.href = '/login';\n        }\n        return Promise.reject(new Error('No access token in refresh response'));\n      }\n    } catch (refreshError) {\n      // Clear any stored tokens and redirect to login\n      localStorage.removeItem('accessToken');\n      if (!isLoginPage) {\n        window.location.href = '/login';\n      }\n      processQueue(refreshError, '');\n      return Promise.reject(refreshError);\n    } finally {\n      isRefreshing = false;\n    }\n  }\n\n  // For other errors, just reject\n  return Promise.reject(error);\n});\n\n// Export the authService that was defined earlier\nexport { authService };\nexport const weatherService = {\n  async getWeatherData(city = 'London') {\n    try {\n      const response = await api.get(`/weather?city=${encodeURIComponent(city)}`);\n      return response.data;\n    } catch (error) {\n      var _error$response3, _error$response3$data;\n      return {\n        success: false,\n        message: ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.message) || 'Failed to fetch weather data'\n      };\n    }\n  }\n};\nexport default api;","map":{"version":3,"names":["axios","API_BASE_URL","process","env","REACT_APP_API_URL","api","create","baseURL","withCredentials","headers","isRefreshing","failedQueue","processQueue","error","token","forEach","prom","reject","resolve","interceptors","request","use","config","_document$querySelect","localStorage","getItem","csrfToken","document","querySelector","getAttribute","Authorization","authService","login","credentials","_response$data$data","console","log","response","post","data","success","accessToken","setItem","user","warn","username","_error$response","_error$response$data","errorMessage","message","logout","removeItem","_error$response2","_error$response2$data","refreshToken","_response$data$data2","_originalRequest$url","originalRequest","Promise","isAuthRequest","url","includes","isLoginPage","window","location","pathname","status","push","href","Error","refreshError","weatherService","getWeatherData","city","get","encodeURIComponent","_error$response3","_error$response3$data"],"sources":["/Users/aparnar/CascadeProjects/streaming-platform/frontend/src/services/api.ts"],"sourcesContent":["import axios, { AxiosError, AxiosRequestConfig } from 'axios';\nimport { User, LoginFormData, WeatherData, ApiResponse } from '../types';\n\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000';\n\nconst api = axios.create({\n  baseURL: API_BASE_URL,\n  withCredentials: true,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\nlet isRefreshing = false;\nlet failedQueue: Array<{ resolve: (token: string) => void; reject: (error: any) => void }> = [];\n\nconst processQueue = (error: any = null, token: string | null = null) => {\n  failedQueue.forEach(prom => {\n    if (error) {\n      prom.reject(error);\n    } else {\n      prom.resolve(token!);\n    }\n  });\n  failedQueue = [];\n};\n\napi.interceptors.request.use((config) => {\n  const token = localStorage.getItem('accessToken');\n  const csrfToken = document.querySelector('meta[name=\"csrf-token\"]')?.getAttribute('content');\n  \n  if (token) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  \n  if (csrfToken) {\n    config.headers['X-CSRF-Token'] = csrfToken;\n  }\n  \n  return config;\n});\n\n// Move authService definition before interceptors that use it\nconst authService = {\n  async login(credentials: LoginFormData): Promise<ApiResponse<User>> {\n    try {\n      console.log('Attempting login with credentials:', credentials);\n      const response = await api.post('/auth/login', credentials);\n      console.log('Login response:', response.data);\n      \n      if (response.data.success && response.data.data?.accessToken) {\n        console.log('Login successful, storing access token');\n        localStorage.setItem('accessToken', response.data.data.accessToken);\n        // Make sure user data is properly set in the response\n        if (!response.data.data.user) {\n          console.warn('Login successful but no user data in response');\n          response.data.data = { ...response.data.data, user: { username: credentials.username } };\n        }\n      } else {\n        console.warn('Login response indicates failure:', response.data);\n      }\n      return response.data;\n    } catch (error: any) {\n      console.error('Login error:', error);\n      const errorMessage = error.response?.data?.message || \n                         error.message || \n                         'Login failed. Please check your network connection and try again.';\n      return {\n        success: false,\n        message: errorMessage,\n      };\n    }\n  },\n\n  async logout(): Promise<ApiResponse<null>> {\n    try {\n      const response = await api.post('/auth/logout');\n      localStorage.removeItem('accessToken');\n      return response.data;\n    } catch (error: any) {\n      return {\n        success: false,\n        message: error.response?.data?.message || 'Logout failed',\n      };\n    }\n  },\n\n  async refreshToken(): Promise<ApiResponse<{ accessToken: string }>> {\n    try {\n      const response = await api.post('/auth/refresh-token');\n      if (response.data.success && response.data.data?.accessToken) {\n        localStorage.setItem('accessToken', response.data.data.accessToken);\n      }\n      return response.data;\n    } catch (error: any) {\n      localStorage.removeItem('accessToken');\n      throw error;\n    }\n  },\n};\n\napi.interceptors.response.use(\n  (response) => response,\n  async (error: AxiosError) => {\n    const originalRequest = error.config as (AxiosRequestConfig & { _retry?: boolean }) | undefined;\n    \n    // If there's no response or the request config is missing, reject\n    if (!error.response || !originalRequest) {\n      return Promise.reject(error);\n    }\n\n    const isAuthRequest = originalRequest.url?.includes('/auth/');\n    const isLoginPage = window.location.pathname === '/login';\n\n    // Handle 401 Unauthorized errors\n    if (error.response.status === 401) {\n      // If we're already on the login page or it's an auth request, reject\n      if (isLoginPage || isAuthRequest) {\n        return Promise.reject(error);\n      }\n\n      // If we're already refreshing the token, add the request to the queue\n      if (isRefreshing) {\n        return new Promise((resolve, reject) => {\n          failedQueue.push({ \n            resolve: (token: string) => {\n              if (originalRequest.headers) {\n                originalRequest.headers.Authorization = `Bearer ${token}`;\n              }\n              resolve(api(originalRequest));\n            }, \n            reject \n          });\n        });\n      }\n\n      // Mark that we're refreshing the token\n      isRefreshing = true;\n\n      try {\n        const response = await authService.refreshToken();\n        const { accessToken } = response.data || {};\n\n        if (accessToken) {\n          // Update the original request with the new token\n          if (originalRequest.headers) {\n            originalRequest.headers.Authorization = `Bearer ${accessToken}`;\n          }\n          \n          // Process any queued requests with the new token\n          processQueue(null, accessToken);\n          \n          // Retry the original request\n          return api(originalRequest);\n        } else {\n          // If no access token in response, redirect to login\n          if (!isLoginPage) {\n            window.location.href = '/login';\n          }\n          return Promise.reject(new Error('No access token in refresh response'));\n        }\n      } catch (refreshError) {\n        // Clear any stored tokens and redirect to login\n        localStorage.removeItem('accessToken');\n        if (!isLoginPage) {\n          window.location.href = '/login';\n        }\n        processQueue(refreshError, '');\n        return Promise.reject(refreshError);\n      } finally {\n        isRefreshing = false;\n      }\n    }\n\n    // For other errors, just reject\n    return Promise.reject(error);\n  }\n);\n\n// Export the authService that was defined earlier\nexport { authService };\n\nexport const weatherService = {\n  async getWeatherData(city: string = 'London'): Promise<ApiResponse<WeatherData>> {\n    try {\n      const response = await api.get(`/weather?city=${encodeURIComponent(city)}`);\n      return response.data;\n    } catch (error: any) {\n      return {\n        success: false,\n        message: error.response?.data?.message || 'Failed to fetch weather data',\n      };\n    }\n  },\n};\n\nexport default api;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}